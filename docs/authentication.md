# Authentication Flow Documentation

**Feature**: Todo Full-Stack Web Application (Phase II)
**Date**: 2026-01-08
**Auth Method**: JWT tokens with Better Auth integration

## Overview

The application uses JWT (JSON Web Token) based authentication with stateless backend architecture. Better Auth (frontend) issues JWT tokens that are validated by the FastAPI backend using a shared secret (BETTER_AUTH_SECRET).

## Authentication Architecture

```
┌─────────────┐                  ┌──────────────┐                  ┌──────────────┐
│  Frontend   │                  │   Backend    │                  │   Database   │
│ (Next.js +  │                  │  (FastAPI)   │                  │(PostgreSQL)  │
│Better Auth) │                  │              │                  │              │
└──────┬──────┘                  └──────┬───────┘                  └──────┬───────┘
       │                                │                                 │
       │  1. Register (email, password) │                                 │
       ├───────────────────────────────►│                                 │
       │                                │ 2. Hash password (bcrypt)       │
       │                                ├────────────────────────────────►│
       │                                │                                 │
       │                                │ 3. Store user (email, hash)     │
       │                                │◄────────────────────────────────┤
       │                                │                                 │
       │  4. Return JWT token           │                                 │
       │  (httpOnly cookie)             │                                 │
       │◄───────────────────────────────┤                                 │
       │                                │                                 │
       │                                │                                 │
       │  5. API request with JWT       │                                 │
       │  (Authorization: Bearer <token>)                                 │
       ├───────────────────────────────►│                                 │
       │                                │ 6. Validate JWT signature       │
       │                                │    using BETTER_AUTH_SECRET     │
       │                                │                                 │
       │                                │ 7. Extract user_id from token   │
       │                                │                                 │
       │                                │ 8. Query scoped to user_id      │
       │                                ├────────────────────────────────►│
       │                                │                                 │
       │                                │ 9. Return user's data only      │
       │                                │◄────────────────────────────────┤
       │                                │                                 │
       │  10. Return response           │                                 │
       │◄───────────────────────────────┤                                 │
       │                                │                                 │
```

## Registration Flow

### Step 1: User Submits Registration Form

**Frontend** (Next.js + Better Auth):
- User enters email and password in registration form
- Client-side validation: email format, password requirements
- Better Auth sends registration request to backend

**Request**:
```http
POST /api/auth/register
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "MyPassword123"
}
```

### Step 2: Backend Validates and Stores User

**Backend** (FastAPI):
1. **Email Validation**: Verify email format using Pydantic (FR-002)
2. **Password Validation**: Check minimum 8 characters, at least one letter and one number (FR-003)
3. **Duplicate Check**: Verify email not already registered (unique constraint)
4. **Password Hashing**: Hash password using bcrypt with work factor 12 (FR-004)
5. **Database Insert**: Store user record (id, email, password_hash, timestamps)

**Success Response** (201 Created):
```json
{
  "success": true,
  "data": {
    "message": "Authenticated successfully"
  },
  "error": null
}
```

**Response Headers**:
```http
Set-Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; HttpOnly; Secure; SameSite=Strict; Max-Age=604800
```

### Step 3: JWT Token Issuance

**JWT Payload** (generated by Better Auth or backend):
```json
{
  "user_id": 1,
  "email": "user@example.com",
  "exp": 1736517600  // Unix timestamp (7 days from now)
}
```

**Token Storage**:
- **Frontend**: Token stored in httpOnly cookie (not accessible via JavaScript) (FR-010)
- **Security**: HttpOnly flag prevents XSS attacks, Secure flag requires HTTPS, SameSite prevents CSRF

---

## Login Flow

### Step 1: User Submits Login Form

**Frontend**:
- User enters email and password
- Better Auth sends login request to backend

**Request**:
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "MyPassword123"
}
```

### Step 2: Backend Authenticates User

**Backend**:
1. **Lookup User**: Find user by email (case-insensitive)
2. **Password Verification**: Use bcrypt.checkpw() to compare password with hash (FR-005)
3. **Success**: Generate JWT token with user_id and email
4. **Failure**: Return 400 Bad Request with error message

**Success Response** (200 OK):
```json
{
  "success": true,
  "data": {
    "message": "Authenticated successfully"
  },
  "error": null
}
```

**Failure Response** (400 Bad Request):
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "Invalid email or password",
    "details": {}
  }
}
```

---

## Protected API Request Flow

### Step 1: Frontend Makes Authenticated Request

**Frontend**:
- Extract JWT token from httpOnly cookie
- Include token in Authorization header
- Send request to protected endpoint

**Request**:
```http
GET /api/todos
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Step 2: Backend Validates Token (Middleware)

**JWT Validation Middleware**:
```python
def verify_jwt(token: str) -> dict:
    """Validate JWT token and extract user_id."""
    try:
        # Decode and verify signature using BETTER_AUTH_SECRET
        payload = jwt.decode(
            token,
            BETTER_AUTH_SECRET,
            algorithms=["HS256"]
        )

        # Check expiration
        if payload["exp"] < datetime.utcnow().timestamp():
            raise HTTPException(401, "Token expired")

        # Extract user_id
        user_id = payload["user_id"]
        return {"user_id": user_id, "email": payload["email"]}

    except jwt.InvalidTokenError:
        raise HTTPException(401, "Invalid token")
```

**Validation Checks** (FR-007, FR-008):
1. Token signature is valid (signed with BETTER_AUTH_SECRET)
2. Token has not expired (exp claim < current time)
3. Token payload contains required claims (user_id, email)

### Step 3: Extract User Identity

**Middleware Result**:
- If valid: Extract `user_id` from token payload and inject into request context
- If invalid/missing/expired: Return 401 Unauthorized immediately (FR-008)

### Step 4: User-Scoped Database Query

**Backend Service**:
```python
def get_user_todos(user_id: int, db: Session) -> list[Todo]:
    """Get todos ONLY for authenticated user (FR-023)."""
    return (
        db.query(Todo)
        .filter(Todo.user_id == user_id)  # Critical user isolation
        .order_by(Todo.created_at.desc())
        .all()
    )
```

**Security Enforcement** (FR-009, FR-026):
- **NEVER trust client-provided user_id** - always extract from JWT
- **ALL queries MUST filter by user_id** - prevents data leakage
- **Return 404 for unauthorized access** - not 403 (prevents user enumeration)

---

## Logout Flow

### Step 1: User Clicks Logout

**Frontend**:
- Send logout request to backend
- Clear local authentication state

**Request**:
```http
POST /api/auth/logout
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Step 2: Backend Clears Cookie

**Backend**:
- Return response with Set-Cookie header to clear token

**Response** (200 OK):
```json
{
  "success": true,
  "data": {
    "message": "Logged out successfully"
  },
  "error": null
}
```

**Response Headers**:
```http
Set-Cookie: token=; HttpOnly; Secure; SameSite=Strict; Max-Age=0
```

**Note**: JWT tokens are stateless, so there's no server-side session to invalidate. The token remains valid until expiration, but the frontend discards it.

---

## Token Refresh Strategy

**Phase II Approach**: **No token refresh**

- JWT tokens expire after 7 days
- User must re-login after expiration
- Simpler implementation for hackathon timeline

**Future Enhancement** (Out of Scope):
- Implement refresh tokens for longer sessions
- Short-lived access tokens (15 minutes) + long-lived refresh tokens (30 days)

---

## Security Considerations

### Token Storage: httpOnly Cookies (FR-010)

**✅ SECURE: httpOnly Cookie**
```javascript
// Browser automatically includes cookie in requests
fetch('/api/todos', { credentials: 'include' });

// JavaScript CANNOT access token
console.log(document.cookie); // token not visible
```

**❌ INSECURE: localStorage (DO NOT USE)**
```javascript
// Vulnerable to XSS attacks
localStorage.setItem('token', jwt_token);  // NEVER DO THIS
```

### User Isolation: Always Scope Queries (FR-023, FR-026)

**✅ SECURE: User-scoped query**
```python
todos = db.query(Todo).filter(Todo.user_id == current_user_id).all()
```

**❌ INSECURE: Unscoped query**
```python
todos = db.query(Todo).all()  // Returns ALL users' todos - SECURITY BUG
```

### User Identity: Extract from JWT (FR-009)

**✅ SECURE: Extract from validated JWT**
```python
user_id = jwt_payload["user_id"]  # Already validated by middleware
```

**❌ INSECURE: Trust client request body**
```python
user_id = request.json["user_id"]  # NEVER TRUST CLIENT - SECURITY BUG
```

---

## Error Scenarios

### Missing Authorization Header

**Request**:
```http
GET /api/todos
# No Authorization header
```

**Response** (401 Unauthorized):
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "MISSING_TOKEN",
    "message": "Authorization header required",
    "details": {}
  }
}
```

### Invalid/Tampered Token

**Request**:
```http
GET /api/todos
Authorization: Bearer invalid.tampered.token
```

**Response** (401 Unauthorized):
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "INVALID_TOKEN",
    "message": "Token signature verification failed",
    "details": {}
  }
}
```

### Expired Token

**Request**:
```http
GET /api/todos
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
# Token exp claim is in the past
```

**Response** (401 Unauthorized):
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "TOKEN_EXPIRED",
    "message": "Token has expired, please login again",
    "details": {}
  }
}
```

---

## Environment Configuration

### Required Environment Variables

**Backend (.env)**:
```bash
BETTER_AUTH_SECRET=your-256-bit-secret-key-here  # Must match frontend
JWT_ALGORITHM=HS256
JWT_EXPIRATION_DAYS=7
```

**Frontend (.env.local)**:
```bash
BETTER_AUTH_SECRET=your-256-bit-secret-key-here  # Must match backend
NEXT_PUBLIC_API_URL=http://localhost:8000
```

**CRITICAL**: `BETTER_AUTH_SECRET` MUST be identical on frontend and backend for JWT validation to work.

---

## Testing Authentication

### Test User Registration
```bash
curl -X POST http://localhost:8000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"TestPass123"}' \
  -c cookies.txt  # Save cookie
```

### Test Login
```bash
curl -X POST http://localhost:8000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"TestPass123"}' \
  -c cookies.txt
```

### Test Protected Endpoint
```bash
curl -X GET http://localhost:8000/api/todos \
  -b cookies.txt  # Include saved cookie
```

### Test Multi-User Isolation
```bash
# Register User A
curl -X POST http://localhost:8000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","password":"AlicePass123"}' \
  -c alice_cookies.txt

# Create todo as User A
curl -X POST http://localhost:8000/api/todos \
  -H "Content-Type: application/json" \
  -d '{"title":"Alice Todo"}' \
  -b alice_cookies.txt

# Register User B
curl -X POST http://localhost:8000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"bob@example.com","password":"BobPass123"}' \
  -c bob_cookies.txt

# Get todos as User B (should NOT see Alice's todo)
curl -X GET http://localhost:8000/api/todos \
  -b bob_cookies.txt
```

---

## Summary

**Authentication Method**: JWT with Better Auth integration
**Token Storage**: httpOnly cookies (secure, XSS-proof)
**Token Validation**: Shared secret (BETTER_AUTH_SECRET)
**User Isolation**: user_id extracted from JWT, all queries scoped
**Session Model**: Stateless (no server-side session storage)
**Token Expiration**: 7 days (configurable)

**Security Requirements Met**:
- ✅ JWT authentication on all protected endpoints (FR-007)
- ✅ Reject invalid/missing/expired tokens (FR-008)
- ✅ Extract user_id from JWT, never trust client (FR-009)
- ✅ httpOnly cookies prevent XSS (FR-010)
- ✅ All queries scoped to authenticated user (FR-023, FR-026)
